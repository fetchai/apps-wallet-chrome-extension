"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = void 0;

var fs = _interopRequireWildcard(require("fs"));

var _assert = _interopRequireDefault(require("assert"));

var _address = require("./crypto/address");

var _bitvector = require("./bitvector");

var _contracts = require("./api/contracts");

var _crypto = require("crypto");

var _atob = _interopRequireDefault(require("atob"));

var _btoa = _interopRequireDefault(require("btoa"));

var _api = require("./api");

var _utils = require("./utils");

var _errors = require("./errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const _compute_digest = source => {
  const hash_func = (0, _crypto.createHash)('sha256');
  hash_func.update(source);
  const digest = hash_func.digest();
  return new _address.Address(digest);
};

const calc_address = (owner, nonce) => {
  (0, _assert.default)(owner instanceof _address.Address);
  const hash_func = (0, _crypto.createHash)('sha256');
  hash_func.update(owner.toBytes());
  hash_func.update(nonce);
  return hash_func.digest();
};

class Contract {
  constructor(source, owner, nonce = null) {
    (0, _assert.default)(typeof source === 'string');
    this._source = source;
    this._digest = _compute_digest(source);
    this._owner = new _address.Address(owner);
    this._nonce = nonce || (0, _crypto.randomBytes)(8);
    this._address = new _address.Address(calc_address(this._owner, this._nonce)); //TODO add etch parser
    //this._parser = new EtchParser(this._source)
    //TODO get rest of this constructor when we add etch parser
  }

  name() {
    return this._digest.toBytes().toString('hex') + this._address.toHex();
  }

  encoded_source() {
    return (0, _btoa.default)(this._source);
  } // combined getter/setter mimicking the python.


  owner(owner = null) {
    if (owner !== null) this._owner = new _address.Address(owner);
    return this._owner;
  }

  digest() {
    return this._digest;
  }

  source() {
    return this._source;
  }

  dumps() {
    return JSON.stringify(this._to_json_object());
  }

  dump(fp) {
    fs.writeFileSync(fp, JSON.stringify(this._to_json_object()));
  }

  static loads(s) {
    return Contract._from_json_object(JSON.parse(s));
  }

  static load(fp) {
    const obj = JSON.parse(fs.readFileSync(fp, 'utf8'));
    return Contract._from_json_object(obj);
  }

  nonce() {
    return (0, _btoa.default)(this._nonce);
  }

  nonce_bytes() {
    return this._nonce;
  }

  address() {
    return this._address;
  }

  async create(api, owner, fee) {
    this.owner(owner);

    if (this._init === null) {
      throw new _errors.RunTimeError('Contract has no initialisation function');
    }

    let shard_mask;

    try {
      //TODO modify hen added etch parser
      // temp we put empty shard mask.
      shard_mask = new _bitvector.BitVector();
    } catch (e) {
      _utils.logger.info('WARNING: Couldn\'t auto-detect used shards, using wildcard shard mask');

      shard_mask = new _bitvector.BitVector();
    }

    return Contract._api(api).create(owner, fee, this, shard_mask);
  }

  async query(api, name, data) {
    if (this._owner === null) {
      throw new _errors.RunTimeError('Contract has no owner, unable to perform any queries. Did you deploy it?');
    } // if(!this.queries.contains(name)){
    //     throw new RunTimeError(name + ' is not an valid query name. Valid options are: ' + this.queries.join(','))
    // }


    const [success, response] = await Contract._api(api).query(this._digest, this._address, name, data);

    if (!success) {
      if (response !== null && 'msg' in response) {
        throw new _errors.RunTimeError('Failed to make requested query: ' + response['msg']);
      } else {
        throw new _errors.RunTimeError('Failed to make requested query with no error message.');
      }
    }

    return response['result'];
  }

  async action(api, name, fee, signers, args) {
    // verify if we are used undefined
    if (this._owner === null) {
      throw new _errors.RunTimeError('Contract has no owner, unable to perform any actions. Did you deploy it?');
    } // if(!name in this._actions){
    //      throw new RunTimeError(`${name} is not an valid action name. Valid options are: ${this._actions.join(',')}`)
    //  }
    // (self, api: ContractsApiLike, name: str, fee: int, signers: List[Entity], *args):


    let shard_mask;

    try {
      // Generate resource addresses used by persistent globals
      // const resource_addresses = [ShardMask.state_to_address(address, self) for address in
      //                       self._parser.used_globals_to_addresses(name, list(args))]
      // Generate shard mask from resource addresses
      //   const shard_mask = ShardMask.resources_to_shard_mask(resource_addresses, api.server.num_lanes())
      shard_mask = new _bitvector.BitVector();
    } catch (e) {
      _utils.logger.info('WARNING: Couldn\'t auto-detect used shards, using wildcard shard mask');

      shard_mask = new _bitvector.BitVector();
    }

    return Contract._api(api).action(this._digest, this._address, name, fee, this._owner, signers, args, shard_mask);
  }

  static _api(ContractsApiLike) {
    if (ContractsApiLike instanceof _contracts.ContractsApi) {
      return ContractsApiLike;
    } else if (ContractsApiLike instanceof _api.LedgerApi) {
      return ContractsApiLike.contracts;
    } else {
      (0, _assert.default)(false);
    }
  }

  static _from_json_object(obj) {
    (0, _assert.default)(obj['version'] === 1);
    const source = (0, _atob.default)(obj.source);
    const owner = obj['owner'];
    const nonce = (0, _atob.default)(obj['nonce']);
    return new Contract(source, owner, nonce);
  }

  _to_json_object() {
    return {
      'version': 1,
      'owner': this._owner.toString(),
      // None if self._owner is None else str(self._owner),
      'source': this.encoded_source(),
      'nonce': this.nonce()
    };
  }

}

exports.Contract = Contract;