"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode_identity = exports.encode_identity = void 0;

var _identity = require("../crypto/identity.js");

var _errors = require("../errors");

// *******************************
// ********** Constants **********
// *******************************
const UNCOMPRESSED_SCEP256K1_PUBLIC_KEY = 0x04; //*** IMPORTANT ****/////

const UNCOMPRESSED_SCEP256K1_PUBLIC_KEY_LEN = 64;

const encode_identity = (buffer, value) => {
  if (value instanceof _identity.Identity) {
    return Buffer.concat([buffer, Buffer.from([UNCOMPRESSED_SCEP256K1_PUBLIC_KEY]), _identity.Identity.public_key_bytes]);
  } else {
    return Buffer.concat([buffer, Buffer.from([UNCOMPRESSED_SCEP256K1_PUBLIC_KEY]), value]);
  }
};

exports.encode_identity = encode_identity;

const decode_identity = buffer => {
  const header = buffer.slice(0, 1);
  const hex = parseInt(header.toString('hex'));

  if (hex !== UNCOMPRESSED_SCEP256K1_PUBLIC_KEY) {
    throw new _errors.ValidationError('Unsupported identity type');
  } // we add one to this value because our key is longer by one, and
  // one because we start our slice ignoring the first.


  const len = UNCOMPRESSED_SCEP256K1_PUBLIC_KEY_LEN + 1;
  const ret = buffer.slice(1, len);
  buffer = buffer.slice(len);
  return [ret, buffer];
};

exports.decode_identity = decode_identity;