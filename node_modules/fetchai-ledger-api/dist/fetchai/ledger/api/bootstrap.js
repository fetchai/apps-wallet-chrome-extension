"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bootstrap = void 0;

var _axios = _interopRequireDefault(require("axios"));

var _errors = require("../errors");

var semver = _interopRequireWildcard(require("semver"));

var _init = require("../init");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Bootstrap {
  static async list_servers(active = true) {
    //Gets list of (active) servers from bootstrap network
    const params = active ? {
      'active': 1
    } : {};
    let resp;

    try {
      resp = await (0, _axios.default)({
        method: 'get',
        url: 'https://bootstrap.fetch.ai/networks/',
        params: params
      });
    } catch (error) {
      throw new _errors.NetworkUnavailableError('Failed to get network status from bootstrap');
    }

    if (200 !== resp.status) {
      throw new _errors.NetworkUnavailableError('Failed to get network status from bootstrap');
    }

    return resp.data;
  }

  static is_server_valid(server_list, network) {
    const available_servers = server_list.map(a => a.name); // Check requested server is on list

    if (!available_servers.includes(network)) {
      throw new _errors.NetworkUnavailableError(`Requested network not present on network: ${network}`);
    }

    let server_details;

    for (let i = 0; i < server_list.length; i++) {
      if (typeof server_list[i]['name'] !== 'undefined' && server_list[i]['name'] === network) {
        server_details = server_list[i];
        break;
      }
    }

    let invalid_flag = false;

    if (server_details['versions'] !== '*') {
      let version_constraints = server_details['versions'].split(',');
      if (typeof server_details['prerelease'] !== 'undefined') invalid_flag = true;
      if (typeof server_details['build'] !== 'undefined') invalid_flag = true;
      if (typeof server_details['patch'] !== 'undefined' && server_details['patch'] !== 0) invalid_flag = true;
      if (!semver.satisfies(semver.coerce(_init.__version__), version_constraints.join(' '))) invalid_flag = true;

      if (invalid_flag) {
        throw new _errors.IncompatibleLedgerVersionError(`Requested network does not support required version\n
                                            Required version: ${semver.coerce(_init.__version__)}\nNetwork supports: ${version_constraints.join(' ')}`);
      }
    }

    return true;
  }

  static async get_ledger_address(network) {
    // Request server endpoints
    const params = {
      'network': network
    };
    let endpoints_response;

    try {
      endpoints_response = await (0, _axios.default)({
        method: 'get',
        url: 'https://bootstrap.fetch.ai/endpoints',
        params: params
      });
    } catch (error) {
      throw new _errors.NetworkUnavailableError('Failed to get network endpoint from bootstrap');
    }

    if (200 !== endpoints_response.status) {
      throw new _errors.NetworkUnavailableError('Failed to get network status from bootstrap, incorrect status code received');
    }

    if (typeof endpoints_response.data[0].address === 'undefined') {
      throw new _errors.RunTimeError('Ledger endpoint missing address');
    }

    return endpoints_response.data[0].address;
  }
  /**
   *Splits a url into a protocol, host name and port
   * @param address
   */


  static split_address(address) {
    let protocol, port;

    if (address.includes('://')) {
      [protocol, address] = address.split('://');
    } else {
      protocol = 'http';
    }

    if (address.includes(':')) {
      [address, port] = address.split(':');
    } else {
      port = protocol == 'https' ? 443 : 8000;
    }

    return [protocol, address, parseInt(port)];
  }
  /**
   * Queries bootstrap for the requested network and returns connection details
   * @param network
   */


  static async server_from_name(network) {
    //Get list of active servers
    const server_list = await Bootstrap.list_servers(true); // Check requested network exists and supports our ledger version

    Bootstrap.is_server_valid(server_list, network); // Get address of network ledger

    const ledger_address = await Bootstrap.get_ledger_address(network); // Check if address contains a port

    const [protocol, host, port] = Bootstrap.split_address(ledger_address);
    return [`${protocol}://${host}`, port];
  }

}

exports.Bootstrap = Bootstrap;