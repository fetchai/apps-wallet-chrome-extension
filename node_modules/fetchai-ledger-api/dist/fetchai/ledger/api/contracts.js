"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContractsApi = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _msgpack = require("@msgpack/msgpack");

var _address = require("../crypto/address");

var _common = require("./common");

var _bitvector = require("../bitvector");

var _contract = require("../contract");

var _transaction = require("../serialization/transaction");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This class for all Tokens APIs.
 *
 * @public
 * @class
 */
class ContractsApi extends _common.ApiEndpoint {
  /**
   *
   * @param {String} HOST Ledger host.
   * @param {String} PORT Ledger port.
   */
  constructor(HOST, PORT) {
    super(HOST, PORT); // tidy up before submitting

    this.prefix = 'fetch.contract';
  }
  /**
   * Create contract
   * @param {Object} owner Entity object
   * @param {Number} fee fee associated with the contract creation.
   * @param {String} contract contract
   * @param {Object} [shard_mask=null] BitVector object
   */


  async create(owner, fee, contract, shard_mask = null) {
    (0, _assert.default)(contract instanceof _contract.Contract);
    const ENDPOINT = 'create'; // Default to wildcard shard mask if none supplied

    if (shard_mask === null) {
      _utils.logger.info('WARNING: defaulting to wildcard shard mask as none supplied');

      shard_mask = new _bitvector.BitVector();
    }

    const tx = await this.create_skeleton_tx(fee);
    tx.from_address(owner);
    tx.target_chain_code(this.prefix, shard_mask);
    tx.action(ENDPOINT);
    tx.data(JSON.stringify({
      text: contract.encoded_source(),
      digest: contract.digest().toHex(),
      nonce: contract.nonce()
    }));
    tx.add_signer(owner.public_key_hex());
    const encoded_tx = (0, _transaction.encode_transaction)(tx, [owner]);
    contract.owner(owner);
    return await this._post_tx_json(encoded_tx, ENDPOINT);
  }
  /**
   * Query on contract
   * @param {Object} contract_digest Address object
   * @param {Object} contract_owner Address object
   * @param {String} query query string
   * @param {JSON} data json payload
   */


  async query(contract_digest, contract_owner, query, data) {
    (0, _assert.default)(this.isJSON(data));
    const prefix = `${contract_digest.toHex()}.${contract_owner.toString()}`;

    const encoded = this._encode_json_payload(data);

    return await this._post_json(query, encoded, prefix);
  }
  /**
   * Action on ledger/contract
   * @param {Object} contract_digest Address class object
   * @param {Object} contract_address Address class object
   * @param {String} action action
   * @param {Number} fee fee associated with the action.
   * @param {Object} from_address from address
   * @param {Array} signers Entity list
   * @param {*} args arguments
   * @param {Object} shard_mask BitVector object
   */


  async action(contract_digest, contract_address, action, fee, from_address, signers, args, shard_mask = null) {
    if (shard_mask === null) {
      shard_mask = new _bitvector.BitVector();
    } // build up the basic transaction information


    const tx = await this.create_skeleton_tx(fee);
    tx.from_address(from_address);
    tx.target_contract(contract_digest, contract_address, shard_mask);
    tx.action(action);
    tx.data(this._encode_msgpack_payload(args));

    for (let i = 0; i < signers.length; i++) {
      tx.add_signer(signers[i].public_key_hex());
    }

    const encoded_tx = (0, _transaction.encode_transaction)(tx, signers);
    return await this._post_tx_json(encoded_tx, null);
  }

  _encode_msgpack_payload(args) {
    (0, _assert.default)(Array.isArray(args));
    const extensionCodec = new _msgpack.ExtensionCodec();
    extensionCodec.register({
      type: 77,
      encode: object => {
        if (object instanceof _address.Address) {
          return object.toBytes();
        } else {
          return null;
        }
      }
    });
    return (0, _msgpack.encode)(args, {
      extensionCodec
    });
  }

  _encode_json_payload(data) {
    (0, _assert.default)(typeof data === 'object' && data !== null);
    const params = {};
    let new_key; //generic object/array loop

    for (let [key, value] of Object.entries(data)) {
      (0, _assert.default)(typeof key === 'string');

      if (key.endsWith('_')) {
        new_key = key.substring(0, key.length - 1); // mutate key name

        delete Object.assign(data, {
          [new_key]: data[key]
        })[new_key];
        key = new_key;
      }

      if (ContractsApi._is_primitive(value)) {
        params[key] = value;
      } else if (value instanceof _address.Address) {
        params[key] = value.toString();
      } else {
        params[key] = this._encode_json_payload(value);
      }
    }

    return params;
  }

  static _is_primitive(test) {
    return test !== Object(test);
  } // taken from http://stackz.ru/en/4295386/how-can-i-check-if-a-value-is-a-json-object


  isJSON(o) {
    if (typeof o != 'string') {
      o = JSON.stringify(o);
    }

    try {
      JSON.parse(o);
      return true;
    } catch (e) {
      return false;
    }
  }

}

exports.ContractsApi = ContractsApi;