"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LedgerApi = void 0;

var semver = _interopRequireWildcard(require("semver"));

var _init = require("../init");

var _apiError = require("../errors/apiError");

var _contracts = require("./contracts");

var _errors = require("../errors");

var _runTimeError = require("../errors/runTimeError");

var _server = require("./server");

var _token = require("./token");

var _tx = require("./tx");

var _bootstrap = require("./bootstrap");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEFAULT_TIMEOUT = 120000;
/**
 * This class for all ledger APIs.
 *
 * @public
 * @class
 */

class LedgerApi {
  /**
   * @param  {Boolean} host ledger host.
   * @param  {Boolean} port ledger port.
   * @param  {Boolean} network server name.
   */
  constructor(host = false, port = false, network = false) {
    if (network) {
      if (host !== false || port !== false) {
        throw new _errors.ValidationError('Specify either a server name, or a host & port');
      }

      [host, port] = _bootstrap.Bootstrap.server_from_name(network);
    } else if (host === false || port === false) {
      throw new _errors.ValidationError('Must specify either a server name, or a host & port');
    }

    this.tokens = new _token.TokenApi(host, port);
    this.contracts = new _contracts.ContractsApi(host, port);
    this.tx = new _tx.TransactionApi(host, port);
  }
  /** Sync the ledger.
   * this does not block event loop, but waits sync for return of executed
   * digest using a timeout, wrapped in a promise that resolves when we get executed status in response, or
   * rejects if timeouts.
   * @async
   * @method
   * @param  {String} txs transactions string.
   * @param  {Boolean} [timeout=false] units seconds.
   * @returns {Promise} return asyncTimerPromise.
   * @throws {TypeError|RunTimeError} TypeError or RunTimeError on any failures.
   */


  async sync(txs, timeout = false) {
    if (typeof txs === 'string') {
      txs = [txs];
    }

    const limit = timeout === false ? DEFAULT_TIMEOUT : timeout * 1000;

    if (!Array.isArray(txs) || !txs.length) {
      throw new TypeError('Unknown argument type');
    }

    const asyncTimerPromise = new Promise(resolve => {
      const start = Date.now();
      const loop = setInterval(async () => {
        if (txs.length === 0) {
          clearInterval(loop);
          return resolve(true);
        }

        let res;

        for (let i = 0; i < txs.length; i++) {
          try {
            res = await this._poll(txs[i].txs[0]);
          } catch (e) {
            if (!(e instanceof _apiError.ApiError)) {
              throw e;
            }
          } // we expect failed requests to return null, or throw an ApiError


          if (res === true) {
            txs.splice(i, 1);
            i--;
          }
        }

        let elapsed_time = Date.now() - start;

        if (elapsed_time >= limit) {
          throw new _runTimeError.RunTimeError('Timeout exceeded waiting for txs');
        }
      }, 100);
    });
    return asyncTimerPromise;
  }

  async _poll(digest) {
    let status = await this.tx.status(digest);
    console.log('status is', status.status);
    return /Executed|Submitted/.test(status.status);
  }

  static async from_network_name(host, port) {
    const server = new _server.ServerApi(host, port);
    const server_version = await server.version();

    if (!semver.satisfies(semver.coerce(server_version), _init.__compatible__.join(' '))) {
      throw new _errors.IncompatibleLedgerVersionError(`Ledger version running on server is not compatible with this API  \n
                                                 Server version: ${server_version} \nExpected version: ${_init.__compatible__.join(',')}`);
    }

    return true;
  }

}

exports.LedgerApi = LedgerApi;