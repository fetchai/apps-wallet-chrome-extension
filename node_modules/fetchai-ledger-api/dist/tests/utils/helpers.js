"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calc_digest = calc_digest;
exports.calc_address = calc_address;
exports.dummy_address = dummy_address;
exports.equals = equals;
exports.ADDRESSES = exports.IDENTITIES = exports.ENTITIES = exports._PRIVATE_KEYS = exports.RAND_FP = exports.DEFAULT_PORT = exports.LOCAL_HOST = void 0;

var bs58 = _interopRequireWildcard(require("bs58"));

var _crypto = require("crypto");

var _address = require("../../fetchai/ledger/crypto/address");

var _entity = require("../../fetchai/ledger/crypto/entity");

var _identity = require("../../fetchai/ledger/crypto/identity");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const LOCAL_HOST = '127.0.0.1';
exports.LOCAL_HOST = LOCAL_HOST;
const DEFAULT_PORT = 8000;
exports.DEFAULT_PORT = DEFAULT_PORT;
const RAND_FP = '/path/to/file';
exports.RAND_FP = RAND_FP;
const _PRIVATE_KEYS = ['1411d53f88e736eac7872430dbe5b55ac28c17a3e648c388e0bd1b161ab04427', '3436c184890d498b25bc2b5cb0afb6bad67379ebd778eae1de40b6e0f0763825', '4a56a19355f934174f6388b3c80598abb151af79c23d5a7af45a13357fb71253', 'f9d67ec139eb7a1cb1f627357995847392035c1e633e8530de5ab5d04c6e9c33', '80f0e1c69e5f1216f32647c20d744c358e0894ebc855998159017a5acda208ba'];
exports._PRIVATE_KEYS = _PRIVATE_KEYS;

const [ENTITIES, IDENTITIES, ADDRESSES] = (() => {
  const ENTITIES = [],
        IDENTITIES = [],
        ADDRESSES = [];

  for (let i = 0; i < _PRIVATE_KEYS.length; i++) {
    ENTITIES.push(_entity.Entity.from_hex(_PRIVATE_KEYS[i]));
    IDENTITIES.push(new _identity.Identity(ENTITIES[i].public_key()));
    ADDRESSES.push(new _address.Address(ENTITIES[i]));
  }

  return [ENTITIES, IDENTITIES, ADDRESSES];
})(); //TODO remove functions names preceeding underscore.


exports.ADDRESSES = ADDRESSES;
exports.IDENTITIES = IDENTITIES;
exports.ENTITIES = ENTITIES;

function calc_digest(address_raw) {
  const hash_func = (0, _crypto.createHash)('sha256');
  hash_func.update(address_raw);
  return hash_func.digest();
}

function calc_address(address_raw) {
  const digest = calc_digest(address_raw);
  const bytes = calc_digest(digest);
  const checksum = bytes.slice(0, 4);
  const full = Buffer.concat([digest, checksum]);
  const display = bs58.encode(full);
  return [digest, display];
}

function dummy_address() {
  const digest = calc_digest(Buffer.from('rand')); // const bs58_encoded = bs58.encode(digest)

  return new _address.Address(Buffer.from(digest));
}

function equals(x, y) {
  if (x === y) return true;

  for (var p in x) {
    if (!x.hasOwnProperty(p)) continue;
    if (!y.hasOwnProperty(p)) return false;
    if (x[p] === y[p]) continue;
    if (typeof x[p] === 'string' && x[p].length > 150) continue;
    if (typeof x[p] !== 'object') return false;
    if (!equals(x[p], y[p])) return false;
  }

  for (p in y) {
    if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;
  }

  return true;
}