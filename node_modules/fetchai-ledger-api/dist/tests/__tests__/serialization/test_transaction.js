"use strict";

var _transaction = require("../../../fetchai/ledger/transaction");

var _bitvector = require("../../../fetchai/ledger/bitvector");

var _identity = require("../../../fetchai/ledger/crypto/identity");

var _transaction2 = require("../../../fetchai/ledger/serialization/transaction.js");

var bytearray = _interopRequireWildcard(require("../../../fetchai/ledger/serialization/bytearray"));

var _crypto = require("crypto");

var _errors = require("../../../fetchai/ledger/errors");

var _bn = require("bn.js");

var _helpers = require("../../utils/helpers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const _calculate_integer_stream_size = len => {
  if (len < 0x80) {
    return 1;
  } else if (len < 0x100) {
    return 2;
  } else if (len < 0x1000) {
    return 4;
  } else {
    return 8;
  }
};

const EXPECTED_SIGNATURE_BYTE_LEN = 64;

const EXPECTED_SIGNATURE_LENGTH_FIELD_LEN = _calculate_integer_stream_size(EXPECTED_SIGNATURE_BYTE_LEN);

const EXPECTED_SERIAL_SIGNATURE_LENGTH = EXPECTED_SIGNATURE_BYTE_LEN + EXPECTED_SIGNATURE_LENGTH_FIELD_LEN;
describe(':Transaction', () => {
  test('test simple decode transaction ', () => {
    const EXPECTED_PAYLOAD = 'a1440000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d44235130ac5aab442e39f9aa27118956695229212dd2f1ab5b714e9f6bd581511c1010000000001020304050607080418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
    const payload = new _transaction.Transaction();
    payload.from_address(_helpers.IDENTITIES[0]);
    payload.add_transfer(_helpers.IDENTITIES[1], new _bn.BN(256));
    payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
    payload.counter(new _bn.BN('0102030405060708', 'hex'));
    const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
    assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
    const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
    expect(success).toBe(true);
    assertTxAreEqual(payload, tx);
  });
  test('test multiple transfers ', () => {
    const EXPECTED_PAYLOAD = 'a1460000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d4014235130ac5aab442e39f9aa27118956695229212dd2f1ab5b714e9f6bd581511c1010020f478c7f74b50c187bf9a8836f382bd62977baeeaf19625608e7e912aa60098c10200da2e9c3191e3768d1c59ea43f6318367ed9b21e6974f46a60d0dd8976740af6dc2000186a000000000000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
    const payload = new _transaction.Transaction();
    payload.from_address(_helpers.IDENTITIES[0]);
    payload.add_transfer(_helpers.IDENTITIES[1], new _bn.BN(256));
    payload.add_transfer(_helpers.IDENTITIES[2], new _bn.BN(512));
    payload.add_transfer(_helpers.IDENTITIES[3], new _bn.BN(100000));
    payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
    payload.counter(new _bn.BN(new Buffer(8).fill(0)));
    const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
    assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
    const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
    expect(success).toBe(true);
    assertTxAreEqual(payload, tx);
  });
});
test('test synergetic_data_submission', () => {
  const EXPECTED_PAYLOAD = 'a140c000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d4c1271001c3000000e8d4a5100080da2e9c3191e3768d1c59ea43f6318367ed9b21e6974f46a60d0dd8976740af6de6672a9d98da667e5dc25b2bca8acf9644a7ac0797f01cb5968abf39de011df204646174610f7b2276616c7565223a20313233347d00000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.valid_until(new _bn.BN(10000));
  payload.target_contract(_helpers.IDENTITIES[3], _helpers.IDENTITIES[4], new _bitvector.BitVector());
  payload.charge_rate(new _bn.BN(1));
  payload.charge_limit(new _bn.BN(1000000000000));
  payload.action('data');
  payload.synergetic_data_submission(true);
  payload.data('{"value": 1234}');
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD); // attempt to decode a transaction from the generated bytes

  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test chain code', () => {
  const EXPECTED_PAYLOAD = 'a1408000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d400c103e8c2000f4240800b666f6f2e6261722e62617a066c61756e636802676f00000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.charge_rate(new _bn.BN(1000));
  payload.charge_limit(new _bn.BN(1000000));
  payload.target_chain_code('foo.bar.baz', new _bitvector.BitVector());
  payload.action('launch');
  payload.data('go');
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test smart contract', () => {
  const EXPECTED_PAYLOAD = 'a1404000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d400c103e8c2000f424080da2e9c3191e3768d1c59ea43f6318367ed9b21e6974f46a60d0dd8976740af6de6672a9d98da667e5dc25b2bca8acf9644a7ac0797f01cb5968abf39de011df2066c61756e636802676f00000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.charge_rate(new _bn.BN(1000));
  payload.charge_limit(new _bn.BN(1000000));
  payload.target_contract(_helpers.IDENTITIES[3], _helpers.IDENTITIES[4], new _bitvector.BitVector());
  payload.action('launch');
  payload.data('go');
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test validity ranges', () => {
  const EXPECTED_PAYLOAD = 'a1470000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d4024235130ac5aab442e39f9aa27118956695229212dd2f1ab5b714e9f6bd581511c103e820f478c7f74b50c187bf9a8836f382bd62977baeeaf19625608e7e912aa60098c103e8da2e9c3191e3768d1c59ea43f6318367ed9b21e6974f46a60d0dd8976740af6dc103e8e6672a9d98da667e5dc25b2bca8acf9644a7ac0797f01cb5968abf39de011df2c103e864c0c8c103e8c2000f424000000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.add_transfer(_helpers.IDENTITIES[1], new _bn.BN(1000));
  payload.add_transfer(_helpers.IDENTITIES[2], new _bn.BN(1000));
  payload.add_transfer(_helpers.IDENTITIES[3], new _bn.BN(1000));
  payload.add_transfer(_helpers.IDENTITIES[4], new _bn.BN(1000));
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.charge_rate(new _bn.BN(1000));
  payload.charge_limit(new _bn.BN(1000000));
  payload.valid_from(new _bn.BN(100));
  payload.valid_until(new _bn.BN(200));
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test contract with 2bit shard mask', () => {
  const EXPECTED_PAYLOAD = 'a1418000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d464c0c8c103e8c2000f4240010b666f6f2e6261722e62617a066c61756e63680000000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const mask = new _bitvector.BitVector(2);
  mask.set(0, 1);
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.charge_rate(new _bn.BN(1000));
  payload.charge_limit(new _bn.BN(1000000));
  payload.valid_from(new _bn.BN(100));
  payload.valid_until(new _bn.BN(200));
  payload.target_chain_code('foo.bar.baz', mask);
  payload.action('launch');
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test contract with 4bit shard mask', () => {
  const EXPECTED_PAYLOAD = 'a1418000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d464c0c8c103e8c2000f42401c0b666f6f2e6261722e62617a066c61756e63680000000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const mask = new _bitvector.BitVector(4);
  mask.set(3, 1);
  mask.set(2, 1);
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.charge_rate(new _bn.BN(1000));
  payload.charge_limit(new _bn.BN(1000000));
  payload.valid_from(new _bn.BN(100));
  payload.valid_until(new _bn.BN(200));
  payload.target_chain_code('foo.bar.baz', mask);
  payload.action('launch');
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD);
  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test contract with large shard mask', () => {
  // const EXPECTED_PAYLOAD = 'a12180532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d464c0c8c103e8c2000f424041eaab0b666f6f2e6261722e62617a066c61756e6368000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c'
  const EXPECTED_PAYLOAD = 'a1418000532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d464c0c8c103e8c2000f424041eaab0b666f6f2e6261722e62617a066c61756e63680000000000000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c';
  const mask = new _bitvector.BitVector(16);
  mask.set(15, 1);
  mask.set(14, 1);
  mask.set(13, 1);
  mask.set(11, 1);
  mask.set(9, 1);
  mask.set(7, 1);
  mask.set(5, 1);
  mask.set(3, 1);
  mask.set(1, 1);
  mask.set(0, 1);
  const payload = new _transaction.Transaction();
  payload.from_address(_helpers.IDENTITIES[0]);
  payload.add_signer(_helpers.IDENTITIES[0].public_key_hex());
  payload.charge_rate(new _bn.BN(1000));
  payload.charge_limit(new _bn.BN(1000000));
  payload.valid_from(new _bn.BN(100));
  payload.valid_until(new _bn.BN(200));
  payload.target_chain_code('foo.bar.baz', mask);
  payload.action('launch');
  payload.counter(new _bn.BN(new Buffer(8).fill(0)));
  const transaction_bytes = (0, _transaction2.encode_transaction)(payload, [_helpers.ENTITIES[0]]);
  assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD); // attempt to decode a transaction from the generated bytes

  const [success, tx] = (0, _transaction2.decode_transaction)(transaction_bytes);
  expect(success).toBe(true);
  assertTxAreEqual(payload, tx);
});
test('test invalid magic', () => {
  const invalid = Buffer.from([0x00]);
  expect(() => {
    (0, _transaction2.decode_transaction)(invalid);
  }).toThrow(_errors.ValidationError);
});
test('test invalid version', () => {
  const invalid = Buffer.from([0xA1, 0xEF, 0xFF]);
  expect(() => {
    (0, _transaction2.decode_transaction)(invalid);
  }).toThrow(_errors.ValidationError);
});

function assertIsExpectedTx(payload, transaction_bytes, expected_hex_payload) {
  const len = Object.keys(payload.signers()).length; // a payload needs at least one signee

  expect(len).toBeGreaterThan(0); // calculate the serial length of the signatures (so that we can extract the payload)

  const signatures_serial_length = EXPECTED_SERIAL_SIGNATURE_LENGTH * len;
  expect(Buffer.byteLength(transaction_bytes)).toBeGreaterThan(signatures_serial_length);
  const expected_payload_end = Buffer.byteLength(transaction_bytes) - signatures_serial_length;
  const payload_bytes = transaction_bytes.slice(0, expected_payload_end);
  expect(payload_bytes.toString('hex')).toBe(expected_hex_payload);
  const payload_bytes_hash = (0, _crypto.createHash)('sha256').update(payload_bytes, 'utf8').digest(); // loop through and verify all the signatures

  let buffer = transaction_bytes.slice(expected_payload_end);
  let identity;
  let signature;

  for (let signee of Object.keys(payload._signers)) {
    [signature, buffer] = bytearray.decode_bytearray(buffer); // validate the signature is correct for the payload

    identity = new _identity.Identity(Buffer.from(signee, 'hex'));
    expect(identity.verify(payload_bytes_hash, signature)).toBe(true);
  }
}

function assertTxAreEqual(reference, other) {
  expect(reference).toBeInstanceOf(_transaction.Transaction);
  expect(other).toBeInstanceOf(_transaction.Transaction);
  expect(reference.from_address()).toMatchObject(other.from_address());
  expect(reference.transfers()).toMatchObject(other.transfers());
  expect(reference.valid_from().cmp(other.valid_from())).toBe(0);
  expect(reference.valid_from().cmp(other.valid_from())).toBe(0);
  expect(reference.charge_rate().cmp(other.charge_rate())).toBe(0);
  expect(reference.charge_limit().cmp(other.charge_limit())).toBe(0);

  if (typeof reference.contract_digest() === 'string') {
    expect(reference.contract_digest()).toBe(other.contract_digest());
  } else {
    expect(reference.contract_digest()).toMatchObject(other.contract_digest());
  }

  if (typeof reference.contract_address() === 'string') {
    expect(reference.contract_address()).toBe(other.contract_address());
  } else {
    expect(reference.contract_address()).toMatchObject(other.contract_address());
  }

  expect(reference.chain_code()).toBe(other.chain_code());
  expect(reference.action()).toBe(other.action());
  expect(reference.shard_mask()).toMatchObject(other.shard_mask());
  expect(reference.data()).toBe(other.data());
  expect(reference.signers()).toMatchObject(other.signers());
}