"use strict";

var _address = require("../../fetchai/ledger/crypto/address");

var _identity = require("../../fetchai/ledger/crypto/identity");

var bs58 = _interopRequireWildcard(require("bs58"));

var _errors = require("../../fetchai/ledger/errors");

var _helpers = require("../utils/helpers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

describe(':Address', () => {
  test('test construction from string', () => {
    // generate a random 32 byte buffer
    const digest = (0, _helpers.calc_digest)(Buffer.from('rand'));
    const bs58_encoded = bs58.encode(digest);
    const [expected_address_bytes, expected_display] = (0, _helpers.calc_address)(bs58_encoded);
    const address = new _address.Address(expected_display);
    expect(address.toBytes()).toMatchObject(expected_address_bytes);
    expect(address.toString()).toBe(expected_display);
  });
  test('test construction from bytes', () => {
    const digest = (0, _helpers.calc_digest)(Buffer.from('rand'));
    const bs58_encoded = bs58.encode(digest);
    const [expected_address_bytes] = (0, _helpers.calc_address)(bs58_encoded);
    const address = new _address.Address(expected_address_bytes);
    expect(address.toBytes()).toMatchObject(expected_address_bytes);
  });
  test('test construction from address', () => {
    const digest = (0, _helpers.calc_digest)(Buffer.from('rand'));
    const bs58_encoded = bs58.encode(digest);
    const [expected_address_bytes] = (0, _helpers.calc_address)(bs58_encoded);
    const address1 = new _address.Address(expected_address_bytes);
    const address2 = new _address.Address(address1);
    expect(address2.toBytes()).toMatchObject(expected_address_bytes);
  });
  test('test invalid length bytes', () => {
    const digest = (0, _helpers.calc_digest)(Buffer.from('rand'));
    const invalid_address = Buffer.concat([digest, digest]);
    expect(() => {
      new _address.Address(invalid_address);
    }).toThrow(_errors.ValidationError);
  });
  test('test invalid length string', () => {
    const invalid_string = Buffer.from('rand');
    const bs58_encoded = bs58.encode(invalid_string);
    expect(() => {
      new _address.Address(bs58_encoded);
    }).toThrow(_errors.ValidationError);
  });
  test('test invalid type', () => {
    expect(() => {
      new _address.Address(99);
    }).toThrow(_errors.ValidationError);
  });
  test('test hex display', () => {
    const digest = (0, _helpers.calc_digest)(Buffer.from('rand'));
    const bs58_encoded = bs58.encode(digest);
    const [expected_address_bytes] = (0, _helpers.calc_address)(bs58_encoded);
    const address = new _address.Address(expected_address_bytes);
    const address_bytes = address.toBytes();
    const hex_address = address_bytes.toString('hex');
    const actual = address.toHex();
    expect(actual).toBe(hex_address);
  });
  test('test invalid display', () => {
    const digest = (0, _helpers.calc_digest)(Buffer.from('rand'));
    const bs58_encoded = bs58.encode(digest);
    const [, expected_display] = (0, _helpers.calc_address)(bs58_encoded);
    const address = new _address.Address(expected_display);
    const address_bytes = address.toBytes();
    const invalid_checksum = Buffer.from('1134');
    const display = Buffer.concat([address_bytes, invalid_checksum]);
    const bs58invalid = bs58.encode(display);
    expect(() => {
      new _address.Address(Buffer.from(bs58invalid));
    }).toThrow(_errors.ValidationError);
  });
  test('test hardcoded addresses', () => {
    const identity1 = new _identity.Identity(Buffer.from('11f2b9a49c76fdaee79b9f470594b51c09299ef4294ea9cf545be4d9d303cc0d28013a21e085a0a1f68bae3f203c375fae182bc69f994290224b563b43388183', 'hex'));
    const expected_display = 'nLYsNsbFGDgcGJa3e7xn2V82fnpaGZVSuJUHCkeY9Cm6SfEyG';
    const address1 = new _address.Address(expected_display);
    const address2 = new _address.Address(identity1);
    const address1_bytes = address1.toBytes();
    const address2_bytes = address2.toBytes();
    const expected_raw_address = '66f17ebc835641521877ef171e0275e0ce923b02b3cbf1965e59fe950277a582';
    expect(address1_bytes.toString('hex')).toBe(expected_raw_address);
    expect(address2_bytes.toString('hex')).toBe(expected_raw_address);
    expect(address1.toString()).toBe(expected_display);
    expect(address2.toString()).toBe(expected_display);
  });
});