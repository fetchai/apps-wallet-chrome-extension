"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _GROUP, _PropTypes$shape;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// In firefox, setTimeout with duration 0 too short for browser notice the changes in dom
var initialTransitDuration = 20;
var PHASE = {
  CLOSE: 'close',
  CLOSING: 'closing',
  CLOSED: 'closed',
  OPEN: 'open',
  OPENING: 'opening',
  OPENED: 'opened'
};
var GROUP = (_GROUP = {}, _defineProperty(_GROUP, PHASE.CLOSE, PHASE.CLOSE), _defineProperty(_GROUP, PHASE.CLOSED, PHASE.CLOSE), _defineProperty(_GROUP, PHASE.OPENING, PHASE.CLOSE), _defineProperty(_GROUP, PHASE.CLOSING, PHASE.OPEN), _defineProperty(_GROUP, PHASE.OPEN, PHASE.OPEN), _defineProperty(_GROUP, PHASE.OPENED, PHASE.OPEN), _GROUP);

var Expand =
/*#__PURE__*/
function (_Component) {
  _inherits(Expand, _Component);

  function Expand(props) {
    var _this;

    _classCallCheck(this, Expand);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Expand).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "getClientHeight", function () {
      return _this.refWrapper.scrollHeight;
    });

    _defineProperty(_assertThisInitialized(_this), "getDefaultExpandStyle", function () {
      var status = _this.state.status;

      switch (status) {
        case PHASE.OPENING:
        case PHASE.CLOSE:
        case PHASE.CLOSED:
          return {
            height: 0,
            opacity: 0,
            overflow: 'hidden'
          };

        case PHASE.OPENED:
        case PHASE.CLOSING:
          return {
            height: _this.getClientHeight(),
            opacity: 1,
            overflow: 'hidden'
          };

        default:
          return {
            height: 'auto',
            opacity: 1,
            overflow: 'unset'
          };
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getExpandStyle", function () {
      return _objectSpread({}, _this.getDefaultExpandStyle(), {}, _this.props.styles[GROUP[_this.state.status]]);
    });

    _defineProperty(_assertThisInitialized(_this), "getTransition", function (attribute) {
      return "".concat(attribute, " ").concat(_this.props.duration, "ms ").concat(_this.props.easing);
    });

    _defineProperty(_assertThisInitialized(_this), "updateStatus", function (status) {
      return _this.setState({
        status: status
      });
    });

    _defineProperty(_assertThisInitialized(_this), "delay", function (fn, time) {
      _this.timeout = setTimeout(fn, time);
    });

    _defineProperty(_assertThisInitialized(_this), "clearDelay", function () {
      if (_this.timeout) {
        clearTimeout(_this.timeout);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "transit", function (entering, entered, enter) {
      var duration = _this.props.duration;

      _this.updateStatus(entering);

      _this.delay(function () {
        _this.updateStatus(entered);

        _this.delay(function () {
          _this.updateStatus(enter);
        }, duration);
      }, initialTransitDuration);
    });

    _defineProperty(_assertThisInitialized(_this), "toggle", function (open) {
      _this.clearDelay();

      if (open) {
        _this.transit(PHASE.OPENING, PHASE.OPENED, PHASE.OPEN);
      } else {
        _this.transit(PHASE.CLOSING, PHASE.CLOSED, PHASE.CLOSE);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setRef", function (ref) {
      _this.refWrapper = ref;
    });

    _this.state = {
      status: _this.props.open ? PHASE.OPEN : PHASE.CLOSE
    };
    return _this;
  }

  _createClass(Expand, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps
    /* prevState */
    ) {
      if (prevProps.open !== this.props.open) {
        this.toggle(this.props.open);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearDelay();
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var transition = this.props.transitions.map(this.getTransition).join(',');
      return _objectSpread({}, this.getExpandStyle(), {
        transition: transition
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className,
          children = _this$props.children,
          Tag = _this$props.tag;
      var childProps = {
        className: className,
        style: this.getStyle(),
        ref: this.setRef
      };
      return _react["default"].createElement(Tag, childProps, children);
    }
  }]);

  return Expand;
}(_react.Component);

Expand.propTypes = {
  children: _propTypes["default"].node.isRequired,
  open: _propTypes["default"].bool,
  duration: _propTypes["default"].number,
  easing: _propTypes["default"].string,
  className: _propTypes["default"].string,
  tag: _propTypes["default"].string,
  transitions: _propTypes["default"].arrayOf(_propTypes["default"].string),
  styles: _propTypes["default"].shape((_PropTypes$shape = {}, _defineProperty(_PropTypes$shape, PHASE.OPEN, _propTypes["default"].object), _defineProperty(_PropTypes$shape, PHASE.CLOSE, _propTypes["default"].object), _PropTypes$shape))
};
Expand.defaultProps = {
  open: false,
  duration: 400,
  easing: 'ease-in-out',
  className: '',
  tag: 'div',
  transitions: ['height', 'opacity'],
  styles: {}
};
var _default = Expand;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9FeHBhbmQuanN4Il0sIm5hbWVzIjpbImluaXRpYWxUcmFuc2l0RHVyYXRpb24iLCJQSEFTRSIsIkNMT1NFIiwiQ0xPU0lORyIsIkNMT1NFRCIsIk9QRU4iLCJPUEVOSU5HIiwiT1BFTkVEIiwiR1JPVVAiLCJFeHBhbmQiLCJwcm9wcyIsInJlZldyYXBwZXIiLCJzY3JvbGxIZWlnaHQiLCJzdGF0dXMiLCJzdGF0ZSIsImhlaWdodCIsIm9wYWNpdHkiLCJvdmVyZmxvdyIsImdldENsaWVudEhlaWdodCIsImdldERlZmF1bHRFeHBhbmRTdHlsZSIsInN0eWxlcyIsImF0dHJpYnV0ZSIsImR1cmF0aW9uIiwiZWFzaW5nIiwic2V0U3RhdGUiLCJmbiIsInRpbWUiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImVudGVyaW5nIiwiZW50ZXJlZCIsImVudGVyIiwidXBkYXRlU3RhdHVzIiwiZGVsYXkiLCJvcGVuIiwiY2xlYXJEZWxheSIsInRyYW5zaXQiLCJyZWYiLCJwcmV2UHJvcHMiLCJ0b2dnbGUiLCJ0cmFuc2l0aW9uIiwidHJhbnNpdGlvbnMiLCJtYXAiLCJnZXRUcmFuc2l0aW9uIiwiam9pbiIsImdldEV4cGFuZFN0eWxlIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJUYWciLCJ0YWciLCJjaGlsZFByb3BzIiwic3R5bGUiLCJnZXRTdHlsZSIsInNldFJlZiIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm5vZGUiLCJpc1JlcXVpcmVkIiwiYm9vbCIsIm51bWJlciIsInN0cmluZyIsImFycmF5T2YiLCJzaGFwZSIsIm9iamVjdCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNQSxzQkFBc0IsR0FBRyxFQUEvQjtBQUVBLElBQU1DLEtBQUssR0FBRztBQUNaQyxFQUFBQSxLQUFL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Y0F4RCxNQUFNLENBQUN5RCxZQUFQLEdBQXNCO0FBQ3BCL0IsRUFBQUEsSUFBSSxFQUFFLEtBRGM7QUFFcEJiLEVBQUFBLFFBQVEsRUFBRSxHQUZVO0FBR3BCQyxFQUFBQSxNQUFNLEVBQUUsYUFIWTtBQUlwQndCLEVBQUFBLFNBQVMsRUFBRSxFQUpTO0FBS3BCRyxFQUFBQSxHQUFHLEVBQUUsS0FMZTtBQU1wQlIsRUFBQUEsV0FBVyxFQUFFLENBQUMsUUFBRCxFQUFXLFNBQVgsQ0FOTztBQU9wQnRCLEVBQUFBLE1BQU0sRUFBRTtBQVBZLENBQXRCO2VBVWVYLE0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLy8gSW4gZmlyZWZveCwgc2V0VGltZW91dCB3aXRoIGR1cmF0aW9uIDAgdG9vIHNob3J0IGZvciBicm93c2VyIG5vdGljZSB0aGUgY2hhbmdlcyBpbiBkb21cbmNvbnN0IGluaXRpYWxUcmFuc2l0RHVyYXRpb24gPSAyMDtcblxuY29uc3QgUEhBU0UgPSB7XG4gIENMT1NFOiAnY2xvc2UnLFxuICBDTE9TSU5HOiAnY2xvc2luZycsXG4gIENMT1NFRDogJ2Nsb3NlZCcsXG4gIE9QRU46ICdvcGVuJyxcbiAgT1BFTklORzogJ29wZW5pbmcnLFxuICBPUEVORUQ6ICdvcGVuZWQnLFxufTtcblxuY29uc3QgR1JPVVAgPSB7XG4gIFtQSEFTRS5DTE9TRV06IFBIQVNFLkNMT1NFLFxuICBbUEhBU0UuQ0xPU0VEXTogUEhBU0UuQ0xPU0UsXG4gIFtQSEFTRS5PUEVOSU5HXTogUEhBU0UuQ0xPU0UsXG5cbiAgW1BIQVNFLkNMT1NJTkddOiBQSEFTRS5PUEVOLFxuICBbUEhBU0UuT1BFTl06IFBIQVNFLk9QRU4sXG4gIFtQSEFTRS5PUEVORURdOiBQSEFTRS5PUEVOLFxufTtcblxuY2xhc3MgRXhwYW5kIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogdGhpcy5wcm9wcy5vcGVuID8gUEhBU0UuT1BFTiA6IFBIQVNFLkNMT1NFLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzIC8qIHByZXZTdGF0ZSAqLykge1xuICAgIGlmIChwcmV2UHJvcHMub3BlbiAhPT0gdGhpcy5wcm9wcy5vcGVuKSB7XG4gICAgICB0aGlzLnRvZ2dsZSh0aGlzLnByb3BzLm9wZW4pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJEZWxheSgpO1xuICB9XG5cbiAgZ2V0Q2xpZW50SGVpZ2h0ID0gKCkgPT4gdGhpcy5yZWZXcmFwcGVyLnNjcm9sbEhlaWdodDtcblxuICBnZXREZWZhdWx0RXhwYW5kU3R5bGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBQSEFTRS5PUEVOSU5HOlxuICAgICAgY2FzZSBQSEFTRS5DTE9TRTpcbiAgICAgIGNhc2UgUEhBU0UuQ0xPU0VEOlxuICAgICAgICByZXR1cm4geyBoZWlnaHQ6IDAsIG9wYWNpdHk6IDAsIG92ZXJmbG93OiAnaGlkZGVuJyB9O1xuICAgICAgY2FzZSBQSEFTRS5PUEVORUQ6XG4gICAgICBjYXNlIFBIQVNFLkNMT1NJTkc6XG4gICAgICAgIHJldHVybiB7IGhlaWdodDogdGhpcy5nZXRDbGllbnRIZWlnaHQoKSwgb3BhY2l0eTogMSwgb3ZlcmZsb3c6ICdoaWRkZW4nIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geyBoZWlnaHQ6ICdhdXRvJywgb3BhY2l0eTogMSwgb3ZlcmZsb3c6ICd1bnNldCcgfTtcbiAgICB9XG4gIH07XG5cbiAgZ2V0RXhwYW5kU3R5bGUgPSAoKSA9PiAoe1xuICAgIC4uLnRoaXMuZ2V0RGVmYXVsdEV4cGFuZFN0eWxlKCksXG4gICAgLi4udGhpcy5wcm9wcy5zdHlsZXNbR1JPVVBbdGhpcy5zdGF0ZS5zdGF0dXNdXSxcbiAgfSk7XG5cbiAgZ2V0VHJhbnNpdGlvbiA9IChhdHRyaWJ1dGUpID0+IGAke2F0dHJpYnV0ZX0gJHt0aGlzLnByb3BzLmR1cmF0aW9ufW1zICR7dGhpcy5wcm9wcy5lYXNpbmd9YDtcblxuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gdGhpcy5wcm9wcy50cmFuc2l0aW9ucy5tYXAodGhpcy5nZXRUcmFuc2l0aW9uKS5qb2luKCcsJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5nZXRFeHBhbmRTdHlsZSgpLFxuICAgICAgdHJhbnNpdGlvbixcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlU3RhdHVzID0gKHN0YXR1cykgPT4gdGhpcy5zZXRTdGF0ZSh7IHN0YXR1cyB9KTtcblxuICBkZWxheSA9IChmbiwgdGltZSkgPT4ge1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZm4sIHRpbWUpO1xuICB9O1xuXG4gIGNsZWFyRGVsYXkgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIHRyYW5zaXQgPSAoZW50ZXJpbmcsIGVudGVyZWQsIGVudGVyKSA9PiB7XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMudXBkYXRlU3RhdHVzKGVudGVyaW5nKTtcblxuICAgIHRoaXMuZGVsYXkoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVTdGF0dXMoZW50ZXJlZCk7XG5cbiAgICAgIHRoaXMuZGVsYXkoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cyhlbnRlcik7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgfSwgaW5pdGlhbFRyYW5zaXREdXJhdGlvbik7XG4gIH07XG5cbiAgdG9nZ2xlID0gKG9wZW4pID0+IHtcbiAgICB0aGlzLmNsZWFyRGVsYXkoKTtcblxuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLnRyYW5zaXQoUEhBU0UuT1BFTklORywgUEhBU0UuT1BFTkVELCBQSEFTRS5PUEVOKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2l0KFBIQVNFLkNMT1NJTkcsIFBIQVNFLkNMT1NFRCwgUEhBU0UuQ0xPU0UpO1xuICAgIH1cbiAgfTtcblxuICBzZXRSZWYgPSAocmVmKSA9PiB7IHRoaXMucmVmV3JhcHBlciA9IHJlZjsgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGNoaWxkcmVuLCB0YWc6IFRhZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZTogdGhpcy5nZXRTdHlsZSgpLFxuICAgICAgcmVmOiB0aGlzLnNldFJlZixcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxUYWcgey4uLmNoaWxkUHJvcHN9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1RhZz5cbiAgICApO1xuICB9XG59XG5cbkV4cGFuZC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgZHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIGVhc2luZzogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0YWc6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRyYW5zaXRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgc3R5bGVzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIFtQSEFTRS5PUEVOXTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBbUEhBU0UuQ0xPU0VdOiBQcm9wVHlwZXMub2JqZWN0LFxuICB9KSxcbn07XG5cbkV4cGFuZC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9wZW46IGZhbHNlLFxuICBkdXJhdGlvbjogNDAwLFxuICBlYXNpbmc6ICdlYXNlLWluLW91dCcsXG4gIGNsYXNzTmFtZTogJycsXG4gIHRhZzogJ2RpdicsXG4gIHRyYW5zaXRpb25zOiBbJ2hlaWdodCcsICdvcGFjaXR5J10sXG4gIHN0eWxlczoge30sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHBhbmQ7XG4iXX0=